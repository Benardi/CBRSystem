---
title: "Case Based Reasoning System for MSRP estimation"
output:
    html_document:
    df_print: paged
theme: sandstone
---

```{r echo=FALSE, message=FALSE, warning=FALSE}
library(tidyverse)
library(here)
library(FNN)
library(magrittr)

theme_set(theme_bw())
```

## Loading Data

```{r}
read_csv(here("data/data.csv"),
         progress = FALSE, 
         col_types =
           cols(
            Make = col_character(),
            Model = col_character(),
            Year = col_integer(),
            `Engine Fuel Type` = col_character(),
            `Engine HP` = col_integer(),
            `Engine Cylinders` = col_integer(),
            `Transmission Type` = col_character(),
            Driven_Wheels = col_character(),
            `Number of Doors` = col_integer(),
            `Market Category` = col_character(),
            `Vehicle Size` = col_character(),
            `Vehicle Style` = col_character(),
            `highway MPG` = col_integer(),
            `city mpg` = col_integer(),
            Popularity = col_integer(),
            MSRP = col_integer()
            )) %>% 
  drop_na() -> car_data 

car_data %>% 
    glimpse()
```

### Checking for missing values

```{r}
row.has.na <- apply(car_data, 
                    1,
                    function(x){any(is.na(x))})
noquote(paste('Number of rows with misssing values: ',
            sum(row.has.na)))
```

## Remove Categorical variables

```{r}
# dummified <- fastDummies::dummy_columns(car_data)
```

```{r}
## Removing categorical variables for now

num.vars <- sapply(car_data,
                   is.numeric)

car_data <- car_data[num.vars]


## Applying scale to numeric variables except MSRP

num.vars <- sapply(car_data,
                   is.numeric, 
                   simplify=F)

num.vars$MSRP = FALSE
num.vars <- unlist(num.vars)

car_data[num.vars] <- lapply(car_data[num.vars],
                             scale)
```

## Split data into training/testing sets 

```{r}
set.seed(101)

## Adding surrogate key to dataframe
car_data$id <- 1:nrow(car_data)

car_data %>% 
  dplyr::sample_frac(.8) -> train

dplyr::anti_join(car_data, 
                 train, 
                 by = 'id') -> test
```

```{r}
dplyr::semi_join(test, 
                 train, 
                 by = 'id') 
```


## Dissociating predictor from response variable and surrogate key

```{r}
train %>% 
  select(-MSRP,-id) -> train.predictors

train %>% 
  select(MSRP, id) -> train.response

test %>% 
  select(-MSRP,-id) -> test.predictors

test %>% 
  select(MSRP, id) -> test.response
```


### Calculating accumulated error for K Nearest Neighbor at given K

```{r}
require(FNN)

calc_KNN_error <- function(k_val,
                           train_pred,
                           test_pred,
                           label,
                           train_resp,
                           test_res) {
  
  k <- FNN::knn(train_pred,
              test_pred, 
              label,
              k = k_val,
              algorithm="cover_tree")

  indices <- attr(k, "nn.index")
  
  estimates <- c()
  
  for(i in seq(1,nrow(indices),1)) {
    lapply(indices[i,],
         function(x){train_resp[x,]$MSRP}) %>% 
    Reduce("+", .) %>% 
    divide_by(length(indices[i,])) -> result
    estimates <-c(estimates, result)
  }
  
  accum_error <- 0
  
  for(j in seq(1,length(estimates),1)) {
    accum_error <- accum_error + ((estimates[j] - test_res$MSRP[j]) ^ 2 )
  }
  return(accum_error)
}
```

```{r}
results <- data.frame(matrix(ncol = 0, nrow = 10))
results$k <- seq(1,10,1)

accum_err <- c()

for(num in results$k) {

  calc_KNN_error(num,
         train.predictors,
         test.predictors,
         train$id,
         train.response,
         test.response) -> err
  
  accum_err <-c(accum_err, err)
}

results$accum_err <- accum_err

results
```

```{r}
results %>%
  ggplot(aes(k,accum_err)) +
  geom_point(size = 3,
             alpha = .6) + 
  geom_line() +
  scale_x_continuous(breaks=seq(1,10,1)) +
  labs(y="Erro Acumulado", x= "Valor de K") +
  ggtitle("Erro acumulado em função de K")
```


